<!-- markdownlint-disable -->

# CAPACITA√á√ÉO JAVASCRIPT & TYPESCRIPT

---

<details>
    <summary>Sum√°rio</summary>
    <ol>
        <li>
            <a href="#1-extens√µes-para-vscode">Extens√µes para VsCode</a>
        </li>
        <li>
            <a href="#2-overview-java-script">Overview Java Script</a>
        </li>
        <li>
            <a href="#3-primeiro-hello-world">Primeiro Hello World</a>
        </li>
        <li>
            <a href="#4-l√≥gica-de-programa√ß√£o-em-js">L√≥gica de Programa√ß√£o em JS</a>
        </li>
        <ol>
            <li>
                <a href="#41-princ√≠pios-de-programa√ß√£o">Princ√≠pios de programa√ß√£o</a>
            </li>
            <ol>
                <li>
                    <a href="#411-o-que-√©-um-algoritmo">O que √© um algoritmo</a>
                </li>
                <li>
                    <a href="#412-vis√£o-geral-de-todas-estruturas">Vis√£o geral de todas estruturas</a>
                </li>
                <li>
                    <a href="#413-o-que-√©-um-bloco-de-c√≥digo">O que √© um bloco de c√≥digo</a>
                </li>
                <li>
                    <a href="#414-coment√°rio-de-um-c√≥digo">Coment√°rio de um c√≥digo</a>
                </li>
            </ol>
            <li>
                <a href="#42-vari√°veis-letvar-e-const">Vari√°veis (let,var e const)</a>
            </li>
            <li>
                <a href="#43-tipos-de-dados-primitivos-string-boolean-number">Tipos de dados primitivos (string, boolean, number)</a>
            </li>
            <li>
                <a href="#44-estrutura-de-dados-array-e-objetos">Estrutura de dados (array e objetos)</a>
            </li>
            <li>
                <a href="#45-operadores">Operadores</a>
            </li>
            <ol>
                <li>
                    <a href="#451-atribui√ß√£o">Atribui√ß√£o</a>
                </li>
                <li>
                    <a href="#452-destructing">Destructing</a>
                </li>
                <li>
                    <a href="#453-aritm√©ticos">Aritm√©ticos</a>
                </li>
                <li>
                    <a href="#454-relacionais">Relacionais</a>
                </li>
                <li>
                    <a href="#455-l√≥gicos">L√≥gicos</a>
                </li>
                <li>
                    <a href="#456-un√°rio-e-tern√°rio">Un√°rio e Tern√°rio</a>
                </li>
            </ol>
            <li>
                <a href="#46-estruturas-de-controle">Estruturas de controle</a>
            </li>
            <ol>
                <li>
                    <a href="#461-if">if</a>
                </li>
                <li>
                    <a href="#462-if-else">if else</a>
                </li>
                <li>
                    <a href="#463-switch">switch</a>
                </li>
                <li>
                    <a href="#464-while">while</a>
                </li>
                <li>
                    <a href="#465-do-while">do while</a>
                </li>
                <li>
                    <a href="#466-for">for</a>
                </li>
                <li>
                    <a href="#467-for-in">for in</a>
                </li>
            </ol>
            <li>
                <a href="#47-clonando-objetos-shallow-copy-x-deep-copy">Clonando Objetos, Shallow Copy x Deep Copy</a>
            </li>
            <ol>
                <li>
                    <a href="#471-shallow-copy">Shallow Copy</a>
                </li>
                <li>
                    <a href="#472-deep-copy">Deep Copy</a>
                </li>
            </ol>
            <li>
                <a href="#48-fun√ß√µes">Fun√ß√µes</a>
            </li>
            <ol>
                <li>
                    <a href="#481-fun√ß√£o-arrow">Fun√ß√£o arrow</a>
                </li>
                <li>
                    <a href="#482-fun√ß√µes-do-array">Fun√ß√µes do array</a>
                </li>
                <ol>
                    <li>
                        <a href="#4821-foreach">Foreach</a>
                    </li>
                    <li>
                        <a href="#4822-map">Map</a>
                    </li>
                    <li>
                        <a href="#4823-filter">Filter</a>
                    </li>
                    <li>
                        <a href="#4824-reduce">Reduce</a>
                    </li>
                </ol>
            </ol>
            <li>
                <a href="#49-promises-async-e-await">Promises, Async e Await</a>
            </li>
        </ol>
        <li>
            <a href="#5-type-script">Type Script</a>
        </li>
        <ol>
            <li>
                <a href="#51-tipos-de-dados-b√°sico">Tipos de dados b√°sico</a>
            </li>
            <ol>
                <li>
                    <a href="#511-number">Number</a>
                </li>
                <li>
                    <a href="#512-string">String</a>
                </li>
                <li>
                    <a href="#513-array">Array</a>
                </li>
                <li>
                    <a href="#514-tuple">Tuple</a>
                </li>
                <li>
                    <a href="#515-enum">Enum</a>
                </li>
                <li>
                    <a href="#516-boolean">Boolean</a>
                </li>
                <li>
                    <a href="#517-null-e-undefined">Null e Undefined</a>
                </li>
                <li>
                    <a href="#518-any">Any</a>
                </li>
                <li>
                    <a href="#519-void">Void</a>
                </li>
                <li>
                    <a href="#5110-object">Object</a>
                </li>
            </ol>
            <li>
                <a href="#52-infer√™ncia-de-tipos">Infer√™ncia de Tipos</a>
            </li>
            <li>
                <a href="#53-union-types">Union Types</a>
            </li>
            <li>
                <a href="#54-fun√ß√µes-em-typescript">Fun√ß√µes em TypeScript</a>
            </li>
            <ol>
                <li>
                    <a href="#541-declara√ß√£o-de-fun√ß√µes">Declara√ß√£o de Fun√ß√µes</a>
                </li>
                <li>
                    <a href="#542-par√¢metros-e-tipos">Par√¢metros e Tipos</a>
                </li>
                <li>
                    <a href="#543-valor-de-retorno">Valor de Retorno</a>
                </li>
            </ol>
            <li>
                <a href="#55-interfaces">Interfaces</a>
            </li>
            <ol>
                <li>
                    <a href="#551-criando-e-usando-interfaces">Criando e usando interfaces</a>
                </li>
                <li>
                    <a href="#552-extens√£o-de-tipos-com-interfaces">Extens√£o de tipos com interfaces</a>
                </li>
            </ol>
            <li>
                <a href="#56-type-aliases">Type Aliases</a>
            </li>
            <ol>
                <li>
                    <a href="#561-criando-e-usando-type-aliases">Criando e usando type aliases</a>
                </li>
                <li>
                    <a href="#562-extens√£o-de-tipos-com-type-aliases">Extens√£o de tipos com type aliases</a>
                </li>
            </ol>
            <li>
                <a href="#57-gen√©ricos">Gen√©ricos</a>
            </li>
            <ol>
                <li>
                    <a href="#571-introdu√ß√£o-aos-gen√©ricos">Introdu√ß√£o aos gen√©ricos</a>
                </li>
                <li>
                    <a href="#572-usando-gen√©ricos-em-fun√ß√µes-e-classes">Usando gen√©ricos em fun√ß√µes e classes</a>
                </li>
            </ol>
            <li>
                <a href="#58-tratamento-de-erros">Tratamento de erros</a>
            </li>
            <ol>
                <li>
                    <a href="#581-lidando-com-exce√ß√µes-em-typescript">Lidando com exce√ß√µes em TypeScript</a>
                </li>
                <li>
                    <a href="#582-tipos-de-erro">Tipos de Erro</a>
                </li>
            </ol>
        </ol>
        <li>
            <a href="#6-v√≠deos-de-conte√∫do-complementar"> V√≠deos de conte√∫do complementar</a>
        </li>
        <li>
            <a href="#7-refer√™ncias-bibliogr√°ficas"> Refer√™ncias Bibliogr√°ficas</a>
        </li>
 </ol>
</details>

---

## 1. Extens√µes para VsCode

- Prettier
- ESLint
- Error Lens
- Auto Import
- Color Highlight
- vscode-styled-components
- Color Picker
- Material Icon Theme
- JavaScript (ES6) code snippets
- Rocketseat React Native
- Code Spell Checker
- Brazilian Portuguese - Code Spell Checker
- Tailwind CSS IntelliSense
- Console Ninja
- Git Lens - Git supercharged
- Code Runner

## 2. Overview Java Script

JavaScript (JS) √© uma linguagem leve, interpretada e baseada em objetos com fun√ß√µes de primeira classe (fun√ß√µes que podem ser argumentos de outras fun√ß√µes). Utilizada frequentemente de script para p√°ginas Web. √â uma linguagem baseada em prot√≥tipos (permite a reutiliza√ß√£o de objetos existentes), multi-paradigma e din√¢mica, suportando estilos de orienta√ß√£o a objetos, imperativos e declarativos.
JS roda no client side da web, o que pode ser usado para projetar / programar o comportamento de uma p√°gina web a partir da ocorr√™ncia de um evento. JavaScript √© uma linguagem f√°cil de se aprender mas que tamb√©m √© poderosa, sendo amplamente utilizada para controlar o comportamento de p√°ginas web.
O ECMAScript √© o padr√£o internacional no qual o JavaScript se baseia, e √© mantido pela ECMA International. Enquanto isso, a escolha do nome "JavaScript" pela Netscape em 1995 foi parcialmente uma estrat√©gia de marketing, aproveitando-se da popularidade crescente da linguagem Java na √©poca. Embora os nomes sejam semelhantes, JavaScript n√£o √© Java!! Sintaxe b√°sica √© intencionalmente similar tanto a Java quanto a C++ (if, for, while, switch, try..catch).
Objetos s√£o criados programaticamente em JavaScript, onde m√©todos e propriedades s√£o anexados a objetos vazios em tempo de execu√ß√£o, ao inv√©s das defini√ß√µes sint√°ticas de classe normalmente encontradas em linguagens compiladas como C++ e Java. Assim que um objeto √© constru√≠do, ele pode ser usado como um esquema (ou prot√≥tipo) para se criar objetos similares.
As capacidades din√¢micas de JavaScript incluem a constru√ß√£o de objetos em tempo de execu√ß√£o, listas vari√°veis de par√¢metros, vari√°veis de fun√ß√µes, cria√ß√£o din√¢mica de scripts (atrav√©s da fun√ß√£o eval), introspec√ß√£o de objetos (atrav√©s da estrutura for ... in), e recupera√ß√£o de c√≥digo fonte (programas escritos em JavaScript podem descompilar fun√ß√µes de volta a seus textos originais).

## 3. Primeiro Hello World

## 4. L√≥gica de Programa√ß√£o em JS

### 4.1. Princ√≠pios de programa√ß√£o

#### 4.1.1. O que √© um algoritmo

Algoritmo √© diretamente afetado pela linguagem de programa√ß√£o utilizada, mas ele n√£o √© ligado apenas a programa√ß√£o, na verdade ele √© um sequ√™ncia de passos que s√£o necess√°rios para executar determinada a√ß√£o. Como exemplo, cada pessoa tem um algoritmo ao acordar at√© estar pronto para atividades do dia, tem aqueles que preferem 1¬∞ levantar, 2¬∞ lavar o rosto, 3¬∞ tomar caf√©, 4¬∞ escovar os dentes e 5¬∞ arrumar a cama, tem outros que preferem escovar os dentes antes do caf√©, e aqueles que nem arrumam a cama pois v√£o deitar de novo de noite. Mas, s√£o nestas situa√ß√µes que se consegue observar o que √© um algoritmo.

Al√©m disso, tamb√©m cabe ressaltar que um algoritmo pode conter repeti√ß√µes de tarefas, ou seja, no exemplo dado eu posso tomar caf√© duas vezes, mas tamb√©m, posso tomar caf√© at√© acabar o sono. Assim, observa-se que pode-se haver repeti√ß√µes que ocorrem por um n√∫mero determinado de vezes ou aquelas que acontecem at√© que determinada condi√ß√£o seja satisfeita.

Outra possibilidade em um algoritmo √© a tomada de decis√£o, ou seja, posso decidir se vou executar algum passo ou n√£o. Como no exemplo j√° citado, se a pessoa acordar sem fome, ela pode optar por n√£o tomar o caf√©, ou, como j√° dito, se estiver com √¢nimo, arruma a cama, se n√£o, deixa sem arrumar mesmo.

Algo que deve-se atentar em um algoritmo √© a ordem de execu√ß√£o dos passos, pois estes podem alterar o resultado. Imagine, no exemplo citado, se a pessoa lava o rosto antes de se levantar, isso resultaria no famoso balde de √°gua na cara para acordar. E assim como essa situa√ß√£o n√£o √© muito desejada, os problemas gerados por passos em ordem errada trazem o conhecido ‚Äúbug‚Äù para a programa√ß√£o.

Por fim, um √∫ltimo ponto importante a ressaltar de um algoritmo √© que ele pode ter entradas, processamento (realizar o passo a passo) e liberar uma sa√≠da. Ent√£o, seguindo o exemplo, poderia-se considerar que a entrada √© a pessoa ao acordar e dependendo de como for o processamento, ou seja, os passos, vai ter como sa√≠da uma pessoa feliz ou desanimada para o seu dia.

Como curiosidade deixo que os algoritmos podem ser representados de v√°rias formas, sendo algumas delas:

- Fluxograma
- Linguagem Natural (Ingl√™s, Portugu√™s, Alem√£o, etc)
- Linguagem Artificial (Java Script, Java, C++, Python, etc)
- Pseudo-Linguagem

#### 4.1.2. Vis√£o geral de todas estruturas

Primeiramente √© importante definir os dados, ou seja, s√£o todas as informa√ß√µes que s√£o utilizadas por um algoritmo, sejam estas, uma palavra, um n√∫mero, um valor booleano, um objeto, etc. Desta forma, tem-se as Estruturas de Dados que existem para organizar e administrar os dados que s√£o utilizados.

Desta forma algumas das estruturas de dados cl√°ssicas s√£o:

- Lista (um conjunto de elementos que pode ter ordem ou n√£o)
- Fila (FIFO - First in First out - primeiro a entrar √© o primeiro a sair)
- Pilha (LIFO - Last in First out - √∫ltimo a entrar √© o primeiro a sair)
- √Årvore (como o sistemas de arquivos do computador)
- Tabelas (organizar os dados em linhas e colunas)

Tamb√©m tem-se estruturas b√°sica de dados para as linguagens de programa√ß√£o:

- int (n√∫meros inteiros)
- real (n√∫meros reais, ou seja, n√∫mero com casas decimais)
- char (letras e s√≠mbolos)
- string (conjunto de letras, existe em apenas algumas linguagens)
- bool (valores l√≥gicos, ou seja, verdadeiro ou falso)

Mas algumas linguagens, assim como o JS, n√£o separam o int do real, tudo √© number. E assim, j√° podemos observar que essas estruturas b√°sicas s√£o utilizadas para criar estruturas mais complexas dentro das linguagens, como exemplo na constru√ß√£o de objetos.

Outro ponto √© que nas linguagens de programa√ß√£o os dados podem ser armazenados em vari√°veis ou constantes, que, como o nome indica, guardar√£o, respectivamente, valores que variam com o tempo e valores que s√£o fixos.

Por fim, com os dados armazenados em vari√°veis e organizados pelas estruturas pode-se realizar diversas opera√ß√µes com eles, como as de atribui√ß√£o, aritm√©ticas, relacionais e l√≥gicas.

#### 4.1.3. O que √© um bloco de c√≥digo

Um bloco de c√≥digo √© definido por um par de chaves `{}`, que t√™m a funcionalidade de separar algumas instru√ß√µes espec√≠ficas que comp√µem um grupo de um funcionalidade. Isso ser√° muito importante para quando chegar na parte de fun√ß√µes, mas, por enquanto, tem-se um exemplo de dois blocos de c√≥digo.

```javascript
{
  console.log("Bloco de c√≥digo 1");
}

{
  console.log("Bloco de c√≥digo 2");
}
```

Vale ressaltar que pode-se encontrar um bloco dentro de outro, o que denominamos como blocos aninhados. Mas n√£o h√° como ter uma intersec√ß√£o entre blocos. Sendo assim, segue um exemplo de um bloco aninhado.

```javascript
{
  console.log("Bloco externo");
  {
    console.log("Bloco interno");
  }
}
```

#### 4.1.4. Coment√°rio de um c√≥digo

Aqui no Ex Machina prezamos pelo clean code, ou seja, um c√≥digo que √© de f√°cil entendimento s√≥ de olhar. Para isso, voc√™ deve tentar colocar os nomes de vari√°veis e de fun√ß√µes sempre da maneira mais clara e correlacionada poss√≠vel.

Contudo, coment√°rios podem ser feitos para fornecer uma melhor explica√ß√£o da funcionalidade de um determinado bloco de c√≥digo. Essa pr√°tica de coment√°rios √© altamente recomendada na fase de aprendizagem, pois voc√™ pode aproveitar deste recurso para anotar algo novo ou at√© um macete para guardar como utilizar o conte√∫do aprendido.

Portanto, para fazer um coment√°rio em JS basta colocar duas barras `//` para comentar somente uma linha e barra-asterisco e asterisco-barra `/* */` para comentar v√°rias linhas. Veja como fazer no exemplo abaixo:

```javascript
//esse √© um coment√°rio de uma linha

/*
  esse √© um
  coment√°rio
  de v√°rias linhas
*/
```

OBS: existe um atalho para comentar uma linha ou v√°rias linhas, geralmente basta selecionar as linhas desejadas depois utilizar a teclas CTRL + / (ou CTRL + : ) para comentar as linhas desejadas.

### 4.2. Vari√°veis (let,var e const)

### 4.3. Tipos de dados primitivos (string, boolean, number)

### 4.4. Estrutura de dados (array e objetos)

Como j√° explicitado anteriormente, as estruturas de dados servem para organizar as informa√ß√µes. Sendo assim, duas maneiras comumente utilizadas s√£o o array e os objetos. O primeiro, tamb√©m chamado de vetor, √© uma cole√ß√£o de dados que podem ser de qualquer tipo, at√© mesmo objeto ou outros vetores (matriz), e para sua defini√ß√£o utiliza-se os colchetes [], como nos exemplos abaixo.

```javascript
const numeros = [1, 2, 3, 4, 5];
const letras = ["a", "b", "c", "d", "e"];
const palavras = ["Ol√°", "mundo", "do", "JavaScript"];
```

Como pode-se observar, s√£o v√°rios elementos dentro de um vetor, sendo assim, para acess√°-los basta colocar o nome do vetor e dentro dos colchetes a posi√ß√£o do elemento que voc√™ deseja acessar. √â muito importante lembrar que a contagem come√ßa em 0, ent√£o se voc√™ deseja recuperar o primeiro elemento do array n√∫meros deve digitar: `numeros[0]`. Com esse comando voc√™ receber√° como resposta o n√∫mero 1 presente no vetor.

Esta nota√ß√£o do nome do vetor e colchetes com a posi√ß√£o tamb√©m pode ser utilizada para trocar o valor em uma posi√ß√£o, como exemplo: `letras[2] = 'c'`. Al√©m disso existe a fun√ß√£o `push` para adicionar valores e a `pop` para retirar valores do fim do array. Tamb√©m, cabe ressaltar que existem v√°rias outras fun√ß√µes espec√≠ficas para trabalhar com os arrays, elas ser√£o especificadas na se√ß√£o [4.8.2 Fun√ß√µes do Array](#482-fun√ß√µes-do-array).

J√° quando se trata de objetos diferencia-se um pouco da ideia dos arrays de juntar valores em posi√ß√µes espec√≠ficas. Os objetos na verdade s√£o uma maneira de voc√™ juntar informa√ß√µes, o que permite criar uma estrutura personalizada para o caso em que est√° trabalhando. Como exemplo um produto do site Extoque tem a seguinte estrutura de objeto:

```javascript
const produto = {
  nome: "Arroz",
  categoria: "Alimento",
  descri√ß√£o: "Arroz branco",
  validade: "2022-12-31",
  baixoEstoque: 10.0,
  preco: 25.0,
  quantidade: 15.0,
  unidade: "pacotes",
};
```

Assim, √© poss√≠vel notar que voc√™ pode usar a criatividade com gosto e fazer um objeto que atenda todas as necessidades, como ter dentro dele um array ou at√© mesmo outro objeto.

Para acessar um atributo do objeto, ou seja, uma de suas caracter√≠sticas, basta colocar nome do objeto, ponto e nome do atributo como: `produto.preco`. Outra op√ß√£o √© usar uma nota√ß√£o semelhante a do array: `produto["preco"]`. Ent√£o, essas duas sintaxe, assim como no array, podem ser usadas para inserir ou modificar valores.

Por fim, um ponto importante a se destacar sobre objetos √© que eles n√£o s√£o a mesma coisa que um JSON. Pois, o JSON foi baseado no objeto do JS, mas ele √© um formato textual que √© usado para trocar dados entre sistemas distribu√≠dos (sistemas na internet).

### 4.5. Operadores

#### 4.5.1. Atribui√ß√£o

#### 4.5.2. Destructing

#### 4.5.3. Aritm√©ticos

#### 4.5.4. Relacionais

#### 4.5.5. L√≥gicos

#### 4.5.6. Un√°rio e Tern√°rio

### 4.6. Estruturas de controle

Como j√° familiarizado anteriormente, estruturas agem no sentido de organizar e as estruturas de controle v√£o agir justamente na organiza√ß√£o da execu√ß√£o do c√≥digo, ou seja, qual passo vai seguir, assim como foi explicado na introdu√ß√£o a um algoritmo. Sendo assim, a seguir ser√£o explicadas as principais estruturas utilizadas. Vale ressaltar que, assim como os blocos de c√≥digos, elas podem ser aninhadas entre si ou com outras, visando atingir os objetivos desej√°veis.

#### 4.6.1. if

Estrutura para fazer o ‚Äúse‚Äù, ou seja, ela verifica se um condi√ß√£o √© verdadeira para executar certa parte definida do c√≥digo. Desta forma, utiliza fortemente os operadores relacionais e l√≥gicos. Um exemplo √©:

```javascript
if (nota >= 7) {
  console.log("Aprovado emm, s√≥ sucesso! Passou com " + nota);
}
```

#### 4.6.2. if else

Estrutura que complementa o if. Ou seja, se algo n√£o for verdadeiro ela executar√° a parte do ‚Äúse n√£o‚Äù. Sendo assim, complementando o exemplo acima:

```javascript
if (nota >= 7) {
  console.log("Aprovado emm, s√≥ sucesso! Passou com " + nota);
} else {
  console.log("N√£o foi dessa vez. Sua nota foi " + nota);
}
```

Mas vale ressaltar que pode-se ter uma sequ√™ncia de ifs e elses, al√©m de aninhar essas estruturas.

#### 4.6.3. switch

Essa estrutura, assim como um if, testa se determinada condi√ß√£o √© verdadeira para executar um peda√ßo de c√≥digo. Contudo, ela tem uma entrada de qualquer tipo e casos. Para cada caso, ela verifica se a entrada √© equivalente √† op√ß√£o que o caso fornece.

Se um caso for verdade ele ser√° executado, sen√£o vai procurar at√© achar o primeiro que se encaixe. Nota-se, ent√£o, que se tiver dois casos iguais apenas o superior ser√° executado.

Para ficar mais f√°cil a seguir ser√° apresentado um switch para avaliar a quantidade de estrelas fornecida por um usu√°rio:

```javascript
switch (qntEstrelas) {
  case 1:
    console.log("P√©ssimo");
    break;
  case 2:
    console.log("Ruim");
    break;
  case 3:
    console.log("Regular");
    break;
  case 4:
    console.log("Bom");
    break;
  case 5:
    console.log("Excelente");
    break;
  default:
    console.log("Quantidade de estrelas inv√°lida");
    break;
}
```

Como √© poss√≠vel notar o `:` indica o come√ßo do caso e o `break` indica o final. Mas vale ressaltar que o break n√£o √© obrigat√≥rio e sua omiss√£o pode ser utilizada para quando dois cases diferentes possuem o mesmo retorno, basta coloc√°-los em seguida e colocar no break apenas no case inferior.

Por fim, no exemplo acima pode-se ver que quando n√£o encontra nenhuma op√ß√£o para `qntEstrelas` temos o `default` que funciona justamente para suprir quando n√£o h√° um caso v√°lido. Tamb√©m, vale pontuar que ele n√£o √© obrigat√≥rio, mas √© uma boa pr√°tica de programa√ß√£o.

#### 4.6.4. while

Essa estrutura encaixa-se na categoria de repeti√ß√£o, isso porque, assim como o seu nome indica, enquanto uma afirma√ß√£o for verdadeira ela continuar√° a executar as instru√ß√µes de c√≥digo que se encontram em seu bloco.

Desta forma, ela tamb√©m utiliza as express√µes l√≥gicas seguindo a mesma forma utilizada no if. Em seguida tem-se um exemplo:

```javascript
while (sono === true) {
  console.log("A mimir!");
  sono = Math.random() >= 0.5;
}
```

Vale ressaltar que a instru√ß√£o `Math.random() >= 0.5` apenas foi utilizada para sortear aleatoriamente um booleano. O que indica uma importante caracter√≠stica da estrutura while, nela geralmente n√£o se sabe quantas vezes vai repetir, isso depende da express√£o que est√° sendo testada.

Nesse caso, tamb√©m poderia ter sido utilizada uma sintaxe mais compacta, como no exemplo abaixo.

```javascript
while (sono) {
  console.log("A mimir!");
  sono = Math.random() >= 0.5;
}
```

Isso acontece porque a vari√°vel sono j√° possui um valor booleano, ent√£o a opera√ß√£o `sono === true` sempre ter√° o valor igual a pr√≥pria vari√°vel.

Obs: essa maneira mais compacta tamb√©m pode ser utilizada para outros tipos de vari√°veis (Number, String, etc), que passar√£o por uma convers√£o de tipos para Boolean, o que nem sempre ser√° algo previs√≠vel porque JavaScript √© estranho (e nem √© meme).

#### 4.6.5. do while

Essa estrutura tamb√©m √© uma dentre as de repeti√ß√£o, mas a sua diferen√ßa para o while explicado anteriormente √© a verifica√ß√£o da express√£o. Ou seja, no while primeiro verifica se a express√£o √© verdadeira para depois executar as instru√ß√µes presente no bloco, j√° o do while √© o oposto primeiro executa as instru√ß√µes e depois verifica a express√£o. Esse modelo inverso, garante que pelo menos uma vez ocorrer√° a execu√ß√£o das instru√ß√µes presentes neste bloco. A seguir tem-se o exemplo anterior modificado para o do while:

```javascript
do {
  console.log("A mimir!");
  sono = Math.random() >= 0.5;
} while (sono);
```

Ent√£o, aqui sabemos que pelo menos uma vez ser√° impresso ‚ÄúA mimir!‚Äù o que n√£o acontecia no exemplo anterior.

#### 4.6.6. for

Essa estrutura tamb√©m √© uma repeti√ß√£o, mas diferente do while o seu n√∫mero de repeti√ß√µes √© conhecido antes dela iniciar. Ou seja, deve ser utilizada em contexto que o n√∫mero de repeti√ß√µes √© definido.

Esta estrutura possui uma sintaxe semelhante ao while, mas dentro dos par√™nteses ela apresenta 3 partes principais: sendo a 1¬∞ a defini√ß√£o da vari√°vel que servir√° como um contador para as repeti√ß√µes, a 2¬∞ a express√£o para verificar se a contagem j√° chegou ao ponto desejado e, por fim, a 3¬∞ a forma como a contagem ser√° realizada.

A seguir ser√° apresentado um exemplo de um for que realiza uma contagem de 1 a 10:

```javascript
for (let i = 1; i <= 10; i++) {
  console.log("i:" + i);
}
```

Como podemos observar a vari√°vel i √© setada para 1 que indica de onde a contagem ir√° se iniciar e a express√£o `i <= 10` verifica se j√° chegou ao limite que √© 10. J√° o `i++` √© uma express√£o para indicar que ser√° acrescida uma unidade em i a cada repeti√ß√£o, utilizando o operador un√°rio. Caso desejasse, por exemplo, contar de 2 em 2 elementos poderia utilizar `i+=2`.

#### 4.6.7. for in

Essa estrutura assemelha-se ao for, ou seja, tamb√©m √© utilizada para fazer repeti√ß√£o. Contudo, ela tem como objetivo espec√≠fico percorrer uma estrutura de dados, como um array ou um objeto.

A seguir um exemplo desta fun√ß√£o para cada estrutura de dados citada:

```javascript
const notas = [6.7, 7.4, 9.8, 8.1, 7.7];

for (let i in notas) {
  console.log(i, notas[i]);
}

const pessoa = {
  nome: "Ana",
  sobrenome: "Silva",
  idade: 29,
  peso: 64,
};

for (let atributo in pessoa) {
  console.log(`${atributo} = ${pessoa[atributo]}`);
}
```

### 4.7. Clonando Objetos, Shallow Copy x Deep Copy

#### 4.7.1. Shallow Copy

#### 4.7.2. Deep Copy

### 4.8. Fun√ß√µes

Fun√ß√µes podem ser definidas simplesmente como um conjunto de instru√ß√µes agrupadas em um bloco de c√≥digo. Geralmente elas possuem um objetivo espec√≠fico e podem ou n√£o ter um retorno e par√¢metros.

Outro ponto importante sobre fun√ß√µes √© que no JS elas podem ser criadas de forma literal, armazenadas em um vari√°vel ou em um atributo de um objeto. Como nos exemplos a seguir:

```javascript
//criar de forma literal - sempre retorna undefined por default
function fun1() {}

//armazenar em uma vari√°vel
const fun2 = function () {};

//armazenar em um atributo de objeto
const obj = {};
obj.falar = function () {
  return "Opa";
};
console.log(obj.falar());
```

Para executar (chamar ou invocar) as instru√ß√µes internas de uma fun√ß√£o, basta adicionar o nome da fun√ß√£o e um par de par√™nteses, como foi poss√≠vel observar no √∫ltimo exemplo: `obj.falar()`. Acredito que nesse momento voc√™ deve ter percebido que vem utilizando uma fun√ß√£o desde o in√≠cio desta capacita√ß√£o e agora que se deu conta. E essa fun√ß√£o que j√° √© familiar para voc√™, est√° armazenado em um atributo do console, ou seja, √© a fun√ß√£o log que faz todas as informa√ß√µes serem mostradas no terminal.

Outro ponto importante para as fun√ß√µes s√£o seus par√¢metros, ou seja, os valores que s√£o passados para que seja poss√≠vel realizar alguma opera√ß√£o interna, como exemplo cl√°ssico temos um fun√ß√£o soma que recebe dois par√¢metros e retorna o valor da soma entre eles:

```javascript
const soma = function (x, y) {
  return x + y;
};
```

Por √∫ltimo, cabe ressaltar que foi poss√≠vel observar pelos exemplos que algumas fun√ß√µes possu√≠am a palavra `return` e outras n√£o. Isso significa que uma fun√ß√£o pode ou n√£o ter um retorno, ent√£o no exemplo da fun√ß√£o soma apresentada, ela retorna o valor da soma para onde ele √© necess√°rio (onde a fun√ß√£o foi chamada), mas dependendo da aplica√ß√£o ele poderia ser simplesmente imprimido por um `console.log()` e a fun√ß√£o n√£o retornaria nada.

#### 4.8.1. Fun√ß√£o arrow

Aqui no Ex Machina temos nosso jeito preferido de usar as fun√ß√µes do JS e ela √© o arrow function. A seguir tem-se um exemplo de como uma fun√ß√£o √© transformada para uma fun√ß√µes arrow:

```javascript
let dobroA = function (a) {
  return 2 * a;
};

//fun√ß√£o arrow eh sempre an√¥nima
//deve sempre ser associada a uma vari√°vel
const dobroB = (a) => {
  return 2 * a;
};

const dobroC = (a) => 2 * a; //return est√° impl√≠cito
```

Como pode-se perceber esse tipo de fun√ß√£o tem menos elementos que a fun√ß√£o tradicional, o que deixa mais agrad√°vel de programar e, tamb√©m, como o costume mais f√°cil de entender.

Outro ponto importante para utiliza√ß√£o de fun√ß√µes arrow √© que fun√ß√µes podem receber fun√ß√µes como um par√¢metro e devido ao formato reduzido fornecido pelas arrows elas se encaixam muito bem nesse papel, isso ser√° demonstrado na pr√≥xima se√ß√£o nas Fun√ß√µes do array.

#### 4.8.2. Fun√ß√µes do array

##### 4.8.2.1. Foreach

##### 4.8.2.2. Map

##### 4.8.2.3. Filter

##### 4.8.2.4. Reduce

### 4.9. Promises, Async e Await

At√© o momento vimos c√≥digos s√≠ncronos, ou seja, c√≥digos que a linha de baixo s√≥ √© executada depois que a linha de cima termina sua execu√ß√£o. Nesta se√ß√£o trabalharemos com c√≥digos ass√≠ncronos, ou seja, agora uma fun√ß√£o √© chamada e o c√≥digo continua sendo executado, mas depois que a resposta chega a fun√ß√£o que a chamou a processa. Isso acontece com muita frequ√™ncia quando est√° trabalhando com requisi√ß√µes para um banco de dados voc√™ pede um dado e ele te retorna um promessa que vai processar a sua requisi√ß√£o e quando terminar ele te retorna a sua resposta.

Desta forma, as Promises vieram justamente para trabalhar com essas promessas de retorno para requisi√ß√µes. A seguir tem-se um exemplo simples de uma promise:

```javascript
function falarDepoisDe(segundos, frase) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(frase, "abc");
    }, segundos * 1000);
  });
}

falarDepoisDe(3, "Que legal!")
  .then((frase, abc) => {
    console.log(abc);
    //undefined pq s√≥ aceita um parametro msm mandando 2
    return frase.concat("?!?");
  })
  .then((outraFrase) => console.log(outraFrase)) //chama a vontade
  .catch((e) => console.log(e));
//para tratar erros quando usa o reject, mas chama uma vez s√≥
```

Este exemplo utiliza a fun√ß√£o `setTimeout` para simular a demora por uma resposta, visto que a fun√ß√£o s√≥ retorna algo depois de passar o tempo definido. Sendo assim, a fun√ß√£o falarDepoisDe retorna uma Promise, que tem duas fun√ß√µes internas para tratar o resultado, se o valor requisitado n√£o tiver problemas a fun√ß√£o `resolve` ser√° executada, se ocorrer algum erro durante a espera a fun√ß√£o `reject` que ser√° executada.

J√° sobre a chamada da fun√ß√£o percebe-se que segue o mesmo padr√£o das fun√ß√µes s√≠ncronas, a diferen√ßa consiste no then que passa justamente a fun√ß√£o resolve que a promise ir√° executar. Sobre o `then` pode-se notar que ele pode ser chamado quantas vezes necess√°rias, mas que s√≥ aceita um par√¢metro por vez. J√° a outra diferen√ßa √© o `catch`, o qual se relaciona a fun√ß√£o reject da promise para tratar os erros.

Contudo, a utiliza√ß√£o de promisses com then e catch, al√©m de ser muito verbosa √© complexa de se trabalhar. Por isso, o mais comum e o que utilizamos no Ex √© a dupla famosa Async e Await. A seguir tem-se um exemplo de como eles trabalham como promises:

```javascript
const esperarPor = (tempo = 2000) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Executando promise...");
      resolve();
    }, tempo);
  });
};
//por tr√°s do async e do await sempre tem que ter um promise
const executar = async () => {
  await esperarPor(1500);
  console.log("Async/Await 1...");

  await esperarPor(1500);
  console.log("Async/Await 2...");

  await esperarPor(1500);
  console.log("Async/Await 3...");
};

//se retornasse um valor e quisesse us√°-lo tem que usar o then pq ela retorna uma promise
executar();
```

Como pode-se perceber, o exemplo √© bem semelhante ao anterior, mas dessa vez o Async e Await servem para tratar uma promise como se ela fosse um fun√ß√£o s√≠ncrona, ou seja, primeiro espera-se o retorno da fun√ß√£o para depois continuar a executar o c√≥digo.

Desta forma, como √© poss√≠vel notar, para usar o async e o await, basta criar uma fun√ß√£o que seja ass√≠ncrona colocando o async antes do nome da fun√ß√£o, como demonstrado no exemplo. E, para esperar a resposta, basta colocar o await na frente da chamada de uma fun√ß√£o que retorna uma promise.

Por fim, n√£o necessita o then j√° que o await faz o papel dele e o catch continua sendo opcional como era anteriormente, a diferen√ßa √© que ele √© feito por meio do tratamento de erros, como ser√° explicado na se√ß√£o [5.8. Tratamento de Erros](#58-tratamento-de-erros).

## 5. Type Script

Agora que voc√™ viu v√°rios aspectos do JS, viu como essa √© uma linguagem poderosa e que pode atender aos requisitos de projetos. Contudo, como voc√™ deve ter reparado em nenhum momento quando as vari√°veis eram declaradas, tinha um tipo definido para elas, como por exemplo um ‚Äúnome‚Äù poderia ser do tipo string j√° que sabemos que um nome √© um conjunto de letras.

Tamb√©m cabe ressaltar que as opera√ß√µes do JS podem ou n√£o depender do tipo, como foi explicitado na se√ß√£o 4.7. Desta maneira, a n√£o declara√ß√£o de tipos pode ser uma grande fonte para bugs e um dos maiores indicadores das pesquisas cient√≠ficas que indicam as dores cabe√ßas dos pobres devs.

Sendo assim, o TypeScript (TS) veio ser a nossa dipirona, ele √© respons√°vel por tipar as vari√°veis, ou seja, garantir que um valor esperado em algum lugar do c√≥digo realmente ser√° do tipo que o desenvolvedor espera. Sendo assim, a sintaxe b√°sica para tipar uma vari√°vel √© nomeVariavel: tipo.

Ent√£o nas pr√≥ximas se√ß√µes ser√° apresentado como o TS √© utilizado, voc√™ perceber√° que √© a base do JS, com a diferen√ßa de adicionar tipos. E √© ele que iremos utilizar em nossos desenvolvimento no Ex Machina.

### 5.1. Tipos de dados b√°sico

Primeiramente ser√£o apresentados como o TS funciona para os tipos primitivos que j√° foram familiarizados nas se√ß√µes do JS.

#### 5.1.1. Number

Representa valores num√©ricos, inteiros ou de ponto flutuante.

```typescript
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
```

#### 5.1.2. String

Representa valores de texto.

```typescript
let color: string = "blue";
color = "red";

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.
I'll be ${age + 1} years old next month.`;

let sentence: string =
  "Hello, my name is " +
  fullName +
  ".\n\n" +
  "I'll be " +
  (age + 1) +
  " years old next month.";
```

#### 5.1.3. Array

Representa uma lista de valores de um determinado tipo.

```typescript
let numeros: number[] = [1, 2, 3, 4, 5];
```

#### 5.1.4. Tuple

Representa uma lista ordenada de elementos com tipos espec√≠ficos.

```typescript
let pessoa: [string, number] = ["Xuxa", 60];
```

#### 5.1.5. Enum

√â uma forma de criar um conjunto de valores nomeados. Representa valores enumerados.

```typescript
enum rifa {
  "bicicleta",
  "doce de leite",
  "doce de abobora",
}

enum DiaDaSemana {
  Segunda,
  Terca,
  Quarta,
  Quinta,
  Sexta,
  Sabado,
  Domingo,
}

let hoje: DiaDaSemana = DiaDaSemana.Segunda;
```

#### 5.1.6. Boolean

Representa valores verdadeiros ou falsos.

```typescript
let ativo: boolean = true;
```

#### 5.1.7. Null e Undefined

Null indica o valor nulo e undefined indica o valor indefinido.

```typescript
let u: undefined = undefined;
let n: null = null;
```

#### 5.1.8. Any

Permite que uma vari√°vel tenha qualquer tipo. Seria o ‚Äútipo padr√£o‚Äù/do JS, portanto n√£o faz tanto sentido ser usado.

```typescript
let variavelQualquer: any = "Isso pode ser qualquer coisa";
```

#### 5.1.9. Void

Usado para indicar que uma fun√ß√£o n√£o retorna nenhum valor.

```typescript
function mostrarMensagem(): void {
  console.log("Ol√°, mundo!");
}
```

#### 5.1.10. Object

Tipo `object` em TypeScript √© uma representa√ß√£o gen√©rica de qualquer valor n√£o primitivo. Embora seja flex√≠vel, voc√™ deve ter cuidado ao us√°-lo, pois perde informa√ß√µes detalhadas sobre a estrutura do objeto, o que pode levar a erros de tempo de execu√ß√£o. √â geralmente prefer√≠vel usar tipos mais espec√≠ficos sempre que poss√≠vel para garantir maior seguran√ßa de tipos em seu c√≥digo. Exemplo:

```typescript
let objeto: Object;

objeto = { nome: "Alice" }; // V√°lido
objeto = [1, 2, 3]; // V√°lido
objeto = "Ol√°"; // V√°lido
objeto = 42; // V√°lido
```

No entanto, voc√™ n√£o pode fazer o seguinte sem uma verifica√ß√£o de tipo: objeto.nome;. Isso resultar√° em um erro: ‚ÄúErro, propriedade 'nome' n√£o existe em tipo 'object'‚Äù. Ou seja, a flexibilidade oferecida possibilita bugs.

Para evitar esses bugs e acessar propriedades ou m√©todos em um objeto com tipo object, voc√™ pode usar a verifica√ß√£o de tipo ou realizar uma convers√£o de tipo, como exemplificado a seguir:

```typescript
let objeto: object = { nome: "Alice" };

// Verifica√ß√£o de tipo
if ("nome" in objeto) {
  console.log(objeto["nome"]); // "Alice"
}

// Convers√£o de tipo
let objetoConvertido = objeto as { nome: string };
console.log(objetoConvertido.nome); // "Alice"
```

### 5.2. Infer√™ncia de Tipos

Uma das vantagens do TypeScript √© sua capacidade de inferir tipos automaticamente, o que significa que voc√™ n√£o precisa especificar o tipo de vari√°vel o tempo todo. Por exemplo:

```typescript
let numero = 42; // Infere o tipo "number" automaticamente
let mensagem = "Ol√°, TypeScript!"; //Infere "string" sozinho
```

O TypeScript usa a infer√™ncia de tipos para determinar o tipo das vari√°veis com base no valor atribu√≠do a elas. Isso torna o c√≥digo mais limpo e leg√≠vel, mas voc√™ ainda pode especificar tipos manualmente quando necess√°rio.

Al√©m dos tipos b√°sicos, o TypeScript suporta tipos mais avan√ßados, como uni√µes, interse√ß√µes, tipos gen√©ricos e tipos personalizados. Isso permite criar sistemas de tipos complexos para atender √†s necessidades espec√≠ficas do seu projeto, garantindo maior seguran√ßa e confiabilidade em seu c√≥digo TypeScript.

### 5.3. Union Types

Em Typescript √© poss√≠vel ter mais de um tipo de retorno, como por exemplo:

```typescript
function isNumber(value: string | number) {
   if (typeof value === ‚Äúnumber‚Äù) return true;
   else return false;
}
```

O uso de Union Types √© comum ao se trabalhar com eventos no DOM (HTML), pois o c√≥digo Typescript n√£o tem acesso pr√©vio ao DOM, n√£o sendo assim capaz de identificar se esse elemento existe ou n√£o, por isso null √© comum como um tipo de retorno.

Um exemplo disso √© que ao declarar um querySelector os tipos que aparecem no pr√≥prio editor de texto s√£o ou um HTMLButtonElement ou null. Uma outra maneira de realizar isso √© atrav√©s de um [Optional chaining (?.)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining). Usando essa ferramenta, ao inv√©s de um retorno nulo que joga um erro √© retornado undefined, nos casos que seriam null.

### 5.4. Fun√ß√µes em TypeScript

Nesta se√ß√£o ser√° apresentado os detalhes de como implementar fun√ß√µes em TypeScript e voc√™ poder√° observar as diferen√ßas e semelhan√ßas com rela√ß√£o ao JavaScript.

#### 5.4.1. Declara√ß√£o de Fun√ß√µes

Em TypeScript, voc√™ pode declarar fun√ß√µes de v√°rias maneiras. A maneira mais comum √© usar a sintaxe de fun√ß√£o, onde voc√™ fornece um nome de fun√ß√£o seguido pelos par√¢metros e pelo corpo da fun√ß√£o:

```typescript
function digaOla(nome: string): void {
  console.log(`Ol√°, ${nome}!`);
}
```

Voc√™ tamb√©m pode usar as arrow functions:

```typescript
const digaOla = (nome: string): void => {
  console.log(`Ol√°, ${nome}!`);
};
```

#### 5.4.2. Par√¢metros e Tipos

Em TypeScript, voc√™ pode especificar os tipos de par√¢metros em uma fun√ß√£o para melhorar a seguran√ßa de tipos. Isso ajuda a evitar que erros de tipo ocorram durante a execu√ß√£o.

```typescript
function adicionar(a: number, b: number): number {
  return a + b;
}
```

Neste exemplo, a fun√ß√£o `adicionar` aceita dois par√¢metros, ambos do tipo `number`. O TypeScript ir√° verificar se os argumentos passados para a fun√ß√£o s√£o do tipo correto.

#### 5.4.3. Valor de Retorno

Voc√™ pode especificar o tipo de valor de retorno de uma fun√ß√£o usando `: TipoDeRetorno`. Isso ajuda a indicar qual tipo de valor a fun√ß√£o deve retornar.

```typescript
function soma(a: number, b: number): number {
  return a + b;
}
```

Neste caso, a fun√ß√£o `soma` deve retornar um valor do tipo `number`.

### 5.5. Interfaces

### 5.5.1. Criando e usando interfaces

As interfaces s√£o criadas usando a palavra-chave interface e especificam a forma que um objeto deve ter. Voc√™ pode us√°-las para definir tipos personalizados que s√£o aplicados a vari√°veis, par√¢metros de fun√ß√£o ou valores de retorno.

```typescript
interface EstudanteUNIFEI {
  nome: string;
  matricula: number;
  curso: string;
  anoIngresso: number;
}

const estudante: EstudanteUNIFEI = {
  nome: "Jo√£o",
  matricula: 123456,
  curso: "Engenharia da Computa√ß√£o",
  anoIngresso: 2020,
};
```

#### 5.5.2. Extens√£o de tipos com interfaces

Assim como as classes podem herdar de outras classes, as interfaces podem herdar de outras interfaces. Isso permite que voc√™ compartilhe estruturas comuns entre diferentes tipos de objetos.

```typescript
interface Pessoa {
  nome: string;
  idade: number;
}

interface Funcionario {
  cargo: string;
  salario: number;
}

interface Gerente extends Pessoa, Funcionario {
  departamento: string;
}

const gerente: Gerente = {
  nome: "Jo√£o",
  idade: 35,
  cargo: "Gerente de Projetos",
  salario: 75000,
  departamento: "Desenvolvimento",
};
```

Voc√™ pode estender tipos existentes usando interfaces. Isso √© √∫til quando voc√™ precisa adicionar novas propriedades a um tipo existente sem modificar o c√≥digo original.

```typescript
interface EstudanteUNIFEI {
  nome: string;
  matricula: number;
  curso: string;
  anoIngresso: number;
}

interface ExMachina extends EstudanteUNIFEI {
  anoIngressoProjeto: number;
  anoSaidaProjeto: number;
}

const AlunoDoExMachina: ExMachina = {
  nome: "Ronaldo",
  matricula: 987654,
  curso: "Engenharia El√©trica",
  anoIngresso: 2019,
  anoIngressoProjeto: 2022,
  anoSaidaProjeto: 2023,
};
```

### 5.6. Type Aliases

Assim como as interfaces, o Type Aliases √© utilizado para defini√ß√£o de tipos. A documenta√ß√£o do TypeScript deixa expl√≠cito que escolher entre type aliases e interfaces √© algo muito relacionado ao gosto pessoal.
Contudo aqui no Ex Machina estamos mais acostumados a trabalhar com o Type Aliases, visto que ele √© mais utilizado para tipagem do front-end, enquanto as interfaces s√£o recomendadas para o back-end para trabalhar com objetos node.
Sendo assim, nas pr√≥ximas subse√ß√µes ser√£o replicados os exemplos anteriores para ter-se uma compara√ß√£o clara entre type aliases e interfaces.

#### 5.6.1. Criando e usando type aliases

Para criar um tipo a sintaxe √© parecida com o interface, primeiramente tem-se a palavra reservada type seguida do nome do tipo e da atribui√ß√£o, como no exemplo a seguir:

```typescript
type EstudanteUNIFEI = {
  nome: string;
  matricula: number;
  curso: string;
  anoIngresso: number;
};

const estudante: EstudanteUNIFEI = {
  nome: "Jo√£o",
  matricula: 123456,
  curso: "Engenharia da Computa√ß√£o",
  anoIngresso: 2020,
};
```

#### 5.6.2. Extens√£o de tipos com type aliases

Os types permitem estender de um tipo s√≥ ou de v√°rios por meio da nota√ß√£o &, como no exemplo abaixo:

```typescript
type Pessoa = {
  nome: string;
  idade: number;
};

type Funcionario = {
  cargo: string;
  salario: number;
};

type Gerente = Pessoa &
  Funcionario & {
    departamento: string;
  };
const gerente: Gerente = {
  nome: "Jo√£o",
  idade: 35,
  cargo: "Gerente de Projetos",
  salario: 75000,
  departamento: "Desenvolvimento",
};
```

E como pode-se perceber, foi poss√≠vel adicionar novos atributos ao tipo que foi criado por meio da extens√£o.

### 5.7. Gen√©ricos

Os gen√©ricos no TypeScript permitem que voc√™ escreva c√≥digo que pode funcionar com uma variedade de tipos, mantendo a seguran√ßa de tipos. Eles s√£o especialmente √∫teis para criar fun√ß√µes e classes flex√≠veis que podem ser usadas com diferentes tipos de dados.

### 5.7.1. Introdu√ß√£o aos gen√©ricos

Gen√©ricos s√£o introduzidos usando par√¢metros de tipo, que s√£o especificados entre `<` e `>`. Eles podem ser usados em fun√ß√µes, classes e interfaces para tornar o c√≥digo mais reutiliz√°vel e gen√©rico.

```typescript
function qualquerValor<T>(valor: T): T {
  return valor;
}

// Uso da fun√ß√£o identidade com diferentes tipos de dados
const numero: number = qualquerValor(42); // retorna 42
const texto: string = qualquerValor("Ol√°, TypeScript!");
// retorna "Ol√°, TypeScript!"

const array: number[] = qualquerValor([1, 2, 3]);
// retorna [1, 2, 3]
```

#### 5.7.2. Usando gen√©ricos em fun√ß√µes e classes

Voc√™ pode criar fun√ß√µes gen√©ricas que funcionam com uma ampla gama de tipos de entrada. Al√©m disso, voc√™ pode criar classes gen√©ricas que aceitam tipos personalizados como argumentos.

### 5.8. Tratamento de erros

Ser√£o apresentados conceitos importantes para lidar com exce√ß√µes e erros em TypeScript, permitindo que voc√™ crie um c√≥digo mais robusto e seguro.

#### 5.8.1. Lidando com exce√ß√µes em TypeScript

O TypeScript oferece suporte ao tratamento de exce√ß√µes usando as constru√ß√µes `try`, `catch` e `throw`, assim como em outras linguagens de programa√ß√£o. Aqui est√° um exemplo:

```typescript
try {
  //C√≥digo que pode gerar um erro
  const resultado = 10 / 0; //Tentando dividir por zero
  console.log(resultado); //Esta linha nunca ser√° executada
} catch (erro) {
  // Capturando e lidando com o erro
  console.error("Ocorreu um erro:", erro);
} finally {
  // Bloco opcional que sempre √© executado
  console.log("Execu√ß√£o conclu√≠da.");
}
```

Neste exemplo, tentou-se fazer uma divis√£o por zero, o que resulta em um erro de tempo de execu√ß√£o. O bloco `try` tenta executar o c√≥digo, e se ocorrer um erro, o bloco `catch` √© executado para lidar com a exce√ß√£o.

#### 5.8.2. Tipos de Erro

No TypeScript, voc√™ pode criar tipos de erros personalizados estendendo a classe `Error` ou criando suas pr√≥prias classes de erro. Isso √© √∫til para identificar erros espec√≠ficos do dom√≠nio e trat√°-los adequadamente. Aqui est√° um exemplo:

```typescript
class ErroDaProtese extends Error {
  constructor() {
    super("Erro da Protese M√£ozinha");
    this.name = "ErroDaProtese";
  }
}

try {
  throw new ErroDaProtese();
} catch (erro) {
  if (erro instanceof ErroDaProtese) {
    console.error("Erro capturado:", erro.message);
  } else {
    console.error("Outro erro ocorreu:", erro);
  }
}
```

Neste exemplo, criou-se uma classe de erro personalizado chamada `ErroDaProtese` que estende a classe `Error`. Em seguida, lan√ßou uma inst√¢ncia desse erro e a capturou no bloco `catch`. Foi usada a `instanceof` para verificar se o erro capturado √© uma inst√¢ncia do erro personalizado e, em seguida, tratou o erro de acordo.

## 6. V√≠deos de conte√∫do complementar

- [JavaScript (A linguagem mais AMADA e/ou ODIADA üòÅ) //Dicion√°rio do Programador](https://www.youtube.com/watch?v=Ri76yOpLrNg&ab_channel=C%C3%B3digoFonteTV)
- [Curso de JavaScript e TypeScript do b√°sico ao avan√ßado JS/TS](https://www.udemy.com/course/curso-de-javascript-moderno-do-basico-ao-avancado/?start=0&couponCode=KEEPLEARNING)
  - Utilize o notion do projeto para obter o login de acesso
- [Desvendando DEFINITIVAMENTE as Promises em JavaScript // M√£o no C√≥digo #21](https://www.youtube.com/watch?v=nRJhc6vXyK4&t=436s&ab_channel=C%C3%B3digoFonteTV)
- [Async / Await SIMPLES e DESCOMPLICADO no JavaScript // M√£o no C√≥digo #22](https://www.youtube.com/watch?v=h0sNAXE1ozo&ab_channel=C%C3%B3digoFonteTV)
- [Curso Web Moderno Completo com JavaScript + Projetos](https://www.udemy.com/course/curso-web/?couponCode=LETSLEARNNOWPP)
  - Utilize o notion do projeto para obter o login de acesso
- [JavaScript Funcional e Reativo - PENSE como um Dev JS](https://www.udemy.com/course/javascript-funcional/?couponCode=LETSLEARNNOWPP)
  - Utilize o notion do projeto para obter o login de acesso
- [TypeScript // Dicion√°rio do Programador](https://www.youtube.com/watch?v=gmupEp468lY&ab_channel=C%C3%B3digoFonteTV)
- [VOU APRENDER TYPESCRIPT (3 motivos)](https://www.youtube.com/watch?v=M57zuClvRbM&ab_channel=FilipeDeschamps)
- [TypeScript - O que √© e quais os seus benef√≠cios? | Diego Fernandes](https://www.youtube.com/watch?v=kg2-SMolAV0&ab_channel=Rocketseat)

## 7. Refer√™ncias Bibliogr√°ficas

C√ìDIGO FONTE TV. Programa√ß√£o Orientada a Objetos: Classes e Objetos em TypeScript. [S.l.], [s.d.]. 1 v√≠deo (38min20s). Publicado pelo canal C√≥digoFonteTV em 11 de setembro de 2020. Dispon√≠vel em: https://www.youtube.com/watch?v=gmupEp468lY&ab_channel=C%C3%B3digoFonteTV. Acesso em: 04 maio 2024.

CONSOLE.LOG. Clonando Objetos JavaScript: Shallow vs Deep Copy. Console.log, [S.l.], [s.d.]. Dispon√≠vel em: https://consolelog.com.br/clonando-objetos-javascript-shallow-vs-deep-copy/. Acesso em: 04 maio 2024.

ESTEVAM, Vinicius. Principais diferen√ßas entre Types e Interfaces em TypeScript. Medium, [S.l.], [s.d.]. Dispon√≠vel em: https://viniciusestevam.medium.com/principais-diferen%C3%A7as-entre-types-e-interfaces-em-typescript-a00c945e5357. Acesso em: 04 maio 2024.

Mozilla Developer Network. JavaScript. Dispon√≠vel em: https://developer.mozilla.org/pt-BR/docs/Web/JavaScript. Acesso em: 04 maio 2024.

OPENAI. ChatGPT. [S.l.], [s.d.]. Intelig√™ncia Artificial. Dispon√≠vel em: https://openai.com/chatgpt. Acesso em: 04 maio 2024.

RABELO, Eduardo. TypeScript: Entendendo a Nota√ß√£o de Tipos. Medium, 2024. Dispon√≠vel em: https://oieduardorabelo.medium.com/typescript-entendendo-a-nota%C3%A7%C3%A3o-de-tipos-9e8c1c89ef62. Acesso em: 04 maio 2024.

SILVESTRE, Gabriel. Heran√ßas e Interfaces. Dev.to, [S.l.], [s.d.]. Dispon√≠vel em: https://dev.to/gabrielhsilvestre/herancas-e-interfaces-k0. Acesso em: 04 maio 2024.

TECNOBLOG. O que √© TypeScript? Guia para Iniciantes. Tecnoblog, [S.l.], [s.d.]. Dispon√≠vel em: https://tecnoblog.net/responde/o-que-e-typescript-guia-para-iniciantes/. Acesso em: 04 maio 2024.

TYPESCRIPT. Basic Types. TypeScript Documentation, [S.l.], [s.d.]. Dispon√≠vel em: https://www.typescriptlang.org/docs/handbook/basic-types.html. Acesso em: 04 maio 2024.

TYPESCRIPT. Functions. TypeScript Documentation, [S.l.], [s.d.]. Dispon√≠vel em: https://www.typescriptlang.org/docs/handbook/functions.html. Acesso em: 04 maio 2024.

Udemy. Curso de JavaScript Moderno do B√°sico ao Avan√ßado. Dispon√≠vel em: https://www.udemy.com/course/curso-de-javascript-moderno-do-basico-ao-avancado/learn/lecture/16331758?start=0#overview. Acesso em: 04 maio 2024.

Udemy. Curso Web: HTML, CSS, JavaScript, jQuery, Bootstrap, PHP, MySQL. Dispon√≠vel em: https://www.udemy.com/course/curso-web/. Acesso em: 04 maio 2024.
